#### 前置知识

集合知识

泛型基础



**类型通配符(泛型的高级应用)**

**1、什么是通配符 (?)**
看个例子就明白了。定义两个集合，分别输出两个集合的元素。

```java
public static void main(String[] args) {

		ArrayList<String> a1 = new ArrayList<String>();
		a1.add("a");
		a1.add("b");
		a1.add("c");
		
		ArrayList<Integer> a2 = new ArrayList<Integer>();
		a2.add(1);
		a2.add(2);
		a2.add(3);
	}
```

在我们没学习泛型之前，我们会封装静态方法如下：

```java
public static void printList(ArrayList list){
	  for (Iterator iterator = list.iterator(); iterator.hasNext();) 
	  {
		Object object = (Object) iterator.next();
		System.out.println(object);	
	   }
	}
```

代码买啥毛病，运行也正确。会有一个疑问。为什么参数没定义泛型，但是却可以接受泛型呢？泛型是jdk1.5出来的，老版本肯定要兼容新版本。

在我们学习泛型方法后，我们进一步将代码修改如下:

```java
public static <T> void vistor(ArrayList<T> a){
		Iterator<T> iterator = a.iterator();
	    while(iterator.hasNext()){
	    	T t = iterator.next(); 
	    	System.out.println(t);
	    }
	}
```

定义一个泛型方法。**如果是泛型类，是不允许泛型定义在static上面的**。

如果不想定义泛型方法，又能够解决问题呢？这就要用到一个通配符的玩意

```java
//占位符，也称为通配符。表示元素类型可以匹配任意类型
	public static void sop(ArrayList<?> a){
		for(Iterator<?> it = a.iterator();it.hasNext();){
			System.out.println(it.next());
		}
	}
```

泛型方法T如果是具体类型的话，可以接收`T t = iterator.next();`。？是占位符，不明确具体类型，无法接收。

这种带通配符`ArrayList<?> a`的`List` 仅仅表示他是**各种泛型的父类**，并不能把元素添加到其中。



**2、类型通配符上限定(? extends T)**

同样看一个例子. 定义一个集合，遍历元素的方法并输出

```java
//定义一个Person类
class Person
{
	private String name;
	public Person(String name){
		this.name = name;
	}
	public String getNmae(){
		return this.name;
	}
}
// 定义一个Student 并继承 Person
class Student extends Person
{
	Student(String name){
		super(name);
	}
}

main方法如下
public static void main(String[] args) {
		
		ArrayList<Person> a1 = new ArrayList<Person>();
		a1.add(new Person("abc1"));
		a1.add(new Person("abc2"));
		a1.add(new Person("abc3"));

		printMethod(a1);
		
		
		// 下面是错误的。a2存的是Person，存在继承的话，也能放worker。但是等号右边只能存Student，存不进worker.类型安全问题。左右两边要一致    	 ArrayList<Person> a2 = new ArrayList<Student>(); 如果我想调用也`printMethod(a2);`怎么做？。 
		ArrayList<Student> a2 = new ArrayList<Student>();
		a2.add(new Student("abc--1"));
		a2.add(new Student("abc--2"));
		a2.add(new Student("abc--3"));
		printMethod(a2); 
  
	
	}
	
	public static void printMethod(ArrayList<Person> a1){
		Iterator<Person> it = a1.iterator();
		while(it.hasNext()){
			System.out.println(it.next().getNmae());
		}
	}

```

第一想法直接给占位符。但是带来一问题，不能调用具体方法。

```java
 public static <T> void printMethod(ArrayList<T> a1) {
    Iterator<T> it = a1.iterator();
    while (it.hasNext()) {
      System.out.println(it.next().getNmae()); //这种写法直接报错 根本不知道要去调用哪个方法
    }
  }
```



泛型也是一样的。如果我们想两者兼得，既能打印Stuednt，也能打印Person，我们将`printMethod`修改如下

```java
public static void printMethod(ArrayList<? extends Person> a1){
		Iterator<? extends Person> it = a1.iterator();
		while(it.hasNext()){
			System.out.println(it.next().getNmae());
		}
	}
```

**3、类型通配符下限定<? super T>**

接收T类型或者T的父类型

从集合TreeSet的构造方法我们可以看到 下限定的运用。我们也可以集合实际例子。

```java
TreeSet<Person> ts = new TreeSet<Person>();  //Comparator<? super E> comparator
ts.add(new Person("d"));
ts.add(new Person("f"));
ts.add(new Person("g"));	
```

比较器如下:

```java
// 这边的T写Student和Person都是可以的
class comp implements Comparator<Person>
{
	public int compare(Person s1,Person s2){
		return s1.getNmae().compareTo(s2.getNmae());
	}
}
```

其实限定的目的是为了**扩展**指定类型。

**通过上面比较器参数和我们实现的比较器。如果我们比较器的泛型为 Student,那么只能比较Student。当未来某一天，Person有新子类出现的话，那么该比较器就不适用了。所以Java 的API 的考虑扩展性的同时，已经设置了泛型下限定，你可以传T类型或者T的父类型。**





# java泛型中T和？和有什么区别

**T 代表一种类型**

加在类上:class SuperClass<A>{}

加在方法上:

**public** <T>**void** fromArrayToCollection(T[] a, Collection<T> c){}

方法上的<T>代表括号里面要用到泛型参数，若类中传了泛型，此处可以不传，调用类型上面的泛型参数，前提是方法中使用的泛型与类中传来的泛型一致。

**class People<T>{**

**public** **void** show(T a) {

  }

}

T extends T2 指传的参数为T2或者T2的子类型。

**?是通配符,泛指所有类型**

一般用于定义一个引用变量,这么做的好处是,如下所示,定义一个sup的引用变量，就可以指向多个对象。

SuperClass<?> sup = new SuperClass<String>("lisi");

sup = new SuperClass<People>(new People());

sup = new SuperClass<Animal>(new Animal());

若不用?,用固定的类型的话，则：

SuperClass<String> sup1 = new SuperClass<String>("lisi");

SuperClass<People> sup2 = new SuperClass<People>("lisi");

SuperClass<Animal> sup3 = new SuperClass<Animal>("lisi");

这就是?通配符的好处。



? extends T 指T类型或T的子类型

? super T  指T类型或T的父类型

这个两个一般也是和?一样用在定义引用变量中，但是传值范围不一样

**T和？运用的地方有点不同,?是定义在引用变量上,T是类上或方法上**

 

**如果有泛型方法和非泛型方法,都满足条件,会执行非泛型方法**

**public** **void** show(String s){

   System.***out\***.println("1");

  }

  @Override

  **public** **void** show(T a) {

   System.***out\***.println("2");

  }

***java泛型的两种用法：List<T>是泛型方法，List<?>是限制通配符***

“<T>"和"<?>"，首先要区分开两种不同的场景：

1. 第一，声明一个泛型类或泛型方法。
2. 第二，使用泛型类或泛型方法。
3. 类型参数“<T>”主要用于第一种，声明泛型类或泛型方法。
4. 无界通配符“<?>”主要用于第二种，使用泛型类或泛型方法

