一、**概念**

内部类：可以包含在另外一个类中的类

外部类：包含内部类的类

每个内部类都会被编译为一个独立的类，生成一个独立的字节码文件。

内部类可以方便地访问外部类的私有变量，内部类也可以声明为private从而实现对外完全隐藏。

**分类**

java中的四种内部类（根据定义的位置和方式划分）

- -静态内部类
- -成员内部类
- -方法内部类
- -匿名内部类

**分类介绍**

**-静态内部类**

特征：在类的内部中存在另一个类，且该类被static修饰

使用范围：在外部类内，可以**直接使用**内部类，在外部类范围以外使用`外部类名.静态内部类名`的方式使用内部类

```java
public class StaticOuter {
    private static int shared = 100;
    public static class StaticInner{
        public void staticInnerMethod() {
            System.out.println("Static Inner Method" + shared);
        }
    }
    StaticInner si1 = new StaticInner();
    public void test() {
        StaticInner si = new StaticInner();
        si.staticInnerMethod();
    }
    public static void main(String[] args) {
        StaticOuter so = new StaticOuter();
        so.test();
    //在外部类范围内
        StaticInner si1 = new StaticInner();
        si1.staticInnerMethod();
    //合法
    StaticOuter.StaticInner si2 = new StaticOuter.StaticInner();
        si2.staticInnerMethod();
    }
}
//在外部类范围外
class Test{
    StaticOuter.StaticInner si2 = new StaticOuter.StaticInner();
}


```

**访问范围**

- 静态内部类只能访问外部类中的static变量和方法。
- 静态内部类也可以访问外部类中的private变量。
- 静态内部类中可以定义静态变量和静态方法。

**-成员内部类**

语法:成员内部类作为外部类的一个成员存在

使用方法：

如何新建一个内部类的实例：不能直接使用外部类.内部类的方式，每个成员内部类对象对应一个外部类实例，因此需要先创建一个外部类实例，然后才能生成内部类的实例（如下面代码）

new 外部类名().new 内部类名();

```java
OriginalClass.OriginalInner originalInner = new OriginalClass().new OriginalInner();
```

访问范围：

成员内部类可以访问外部类中的静态变量和方法，也可以访问实例变量和方法。但是书写格式有两种：

（1）直接访问；

（2）`外部类.this.xxx`，主要针对外部类和内部类的出现变量重名或者方法重名的情况。

成员内部类也可以访问外部类的私有变量

成员内部类中不可以定义静态变量和静态方法（final变量例外，它等同于常量），在后面的方法内部类和匿名内部类中也是不能存在静态的变量和方法的，这是因为静态变量和静态方法作为类型的属性和方法，一般是独立使用的，而成员内部类和一个对一个的外部类实例关联，一般不会独立使用，所以这样的使用意义不大。（这算是一种规定吧）。

```java
public class OriginalClass {
    private static int t1 = 100;
    private int t2 = 200;
    class OriginalInner{
        public void test() {
      /*
           * 不合法的表示，在成员内部类中不可以定义静态的变量和方法
          public static int inner = 100;
          public static void print() {
          }
          */
          //合法的final变量
          public static final int inner1 = 300;
            System.out.println("OriginalInner:"+ t1);//直接访问外部类静态变量
            System.out.println("OriginalInner:"+ t2);//直接访问外部类成员变量
            action();//直接访问外部类方法
            System.out.println("OriginalInner:"+ OriginalClass.this.t1);//
            System.out.println("OriginalInner:"+ OriginalClass.this.t2);
            OriginalClass.this.action();
        }
    }
    public void action() {
        System.out.println("originalinner action");
    }
    public static void main(String[] args) {
    //new一个内部类
        OriginalClass oc = new OriginalClass();
        OriginalInner oi = oc.new OriginalInner();
        oi.test();
    }
}


```

**-方法内部类**

语法：存在于方法体内部的类

使用范围：方法内部类只能在定义的方法内被使用

访问范围：

如果包含内部类的方法是实例方法，那么可以访问外部类的静态变量和方法，也可以访问实例变量和方法；

如果包含内部类的方法是静态方法，那么只能访问外部类的静态变量和方法。

方法内部类还可以直接访问方法的参数和方法中的局部变量，但是这些变量必须声明为final。为什么需要声明为final呢？这是因为方法内部类操作的并不是外部的变量，而是它自己的实例变量，只是这些变量的值和外部一样，对这些变量赋值，并不会改变外部的值，为避免混淆，所以干脆强制规定必须声明为final。

我们知道被final修饰的基本类型变量的值是不能被修改的，被final修饰的数组或者引用类型变量的引用是不能修改的，即只能指向一个对象或者是数组，但是我们可以修改对象中的成员变量值或者是数组中元素的值。

其实使用final来修饰参数以及局部变量的目的还是保证方法内部类外面的元素不会在方法内部类中被修改，相当于限制一个作用域的功能，保证方法内部类内部的的修改不会影响方法内部类外面的同名变量值。

```java
public class FunctionOuter {
    private static int s= 100;
    private int s1 = 20;
    public void print(final int param) {
        final int in = 300;
        class FunctionInner{
            public void innertest() {
                System.out.println("FunctionInner：s="+s);
                System.out.println("FunctionInner：s1="+s1);
                System.out.println("FunctionInner：in"+ in);
                test();
            }
        }
        FunctionInner fi = new FunctionInner();
        fi.innertest();
        System.out.println("print:in"+in);
    }
    public void test() {
        System.out.println("FunctionOuter："+s);
    }
    public static void main(String[] args) {
        FunctionOuter fo = new FunctionOuter();
        fo.print(900);
    }
}

```

**-匿名内部类**

语法：匿名内部类没有单独的类定义，它在创建对象的同时定义类

```java
new 一般是接口(参数列表){
  //匿名内部类实现部分
}

```

匿名内部类只能使用一次，用来创建一个对象。没有名字，没有构造方法，但是可以根据参数列表，调用对应的父类构造方法。

在匿名内部类中可以定义实例变量和方法，以及初始化代码块，初始化代码块可以起到构造方法的作用，只是构造方法可以有多个，但是初始化代码块只能有一块，因为没有构造方法，它自己无法接受参数，如果必须要参数，则应该是用其他内部类





二、 **作用**

1.内部类可以很好的实现隐藏

 一般的非内部类，是不允许有 private 与protected权限的，但内部类可以

2．内部类拥有外围类的所有元素的访问权限

3.可是实现多重继承

4.可以避免修改接口而实现同一个类中两种同名方法的调用

5.静态内部类和非静态内部类的区别

三、  **例子**

##### 1.实现隐藏

  平时我们对类的访问权限，都是通过类前面的访问修饰符来限制的，一般的非内部类，是不允许有private 与protected权限的，但内部类可以，所以我们能通过内部类来隐藏我们的信息。可以看下面的例子

接口

```java
public interface Incrementable{
 void increment();
}
```

具体类

```java
public class Example {
  private class InsideClass implementsInterfaceTest{
     public voidtest(){
      System.out.println("这是一个测试");
}
}
  public InterfaceTest getIn() {
    return newInsideClass();
  }
}

public class TestExample {
 public static void main(String args[]) {
 Example a=new Example();
  InterfaceTest a1=a.getIn();
  a1.test();
 }
}
```



从这段代码里面我只知道Example的getIn()方法能返回一个InterfaceTest 实例但我并不知道这个实例是这么实现的。而且由于InsideClass是private的，所以我们如果不看代码的话根本看不到这个具体类的名字，所以说它可以很好的实现隐藏。

##### 2.可以无条件地访问外围类的所有元素

```java
public class TagBean {
 private String name="张三丰";
  private class InTest{
   public InTest(){
     System.out.println(name);
   }
  }
  public void test(){
  new InTest();
  }
  public static void main(String args[]){
   TagBean bb=new TagBean();
	 bb.test();
  }
}
```



name这个变量是在TagBean里面定义的私有变量。这个变量在内部类中可以无条件地访问System.out.println(name);

##### 3.可以实现多重继承

这个特点非常重要，个人认为它是内部类存在的最大理由之一。正是由于他的存在使得Java的继承机制更加完善。大家都知道Java只能继承一个类，它的多重继承在我们没有学习内部类之前是用接口来实现的。但使用接口有时候有很多不方便的地方。比如我们实现一个接口就必须实现它里面的所有方法。而有了内部类就不一样了。它可以使我们的类继承多个具体类或抽象类。大家看下面的例子。

类一

```java
public class Example1 {
  public String name() {
    return "liutao";
  }
}
```

类二

```java
public class Example2 {
  public int age(){
    return 25;
  }
} 
```

类三

```java
 public class MainExample{
  private class test1 extends Example1{
    public String name(){
     returnsuper.name();
    }
  }
  private class test2 extends Example2{
    public int age(){
     returnsuper.age();
    }
  }
  public String name(){
  	return new test1().name();
  }
  public int age(){
    return new test2().age();
  }
  public static void main(String args[]){
  MainExample mi=newMainExample();
    System.out.println("姓名:"+mi.name());
    System.out.println("年龄:"+mi.age());
  }
}
```



注意看类三，里面分别实现了两个内部类 test1,和test2 ，test1类又继承了Example1，test2继承了Example2，这样我们的类三MainExample就拥有了Example1和Example2的方法和属性，也就间接地实现了多继承。

#####  4.避免修改接口而实现同一个类中两种同名方法的调用。

 大家假想一下如果，你的类要继承一个类，还要实现一个接口，可是你发觉你继承的类和接口里面有两个同名的方法怎么办？你怎么区分它们？？这就需要我们的内部类了。看下面的代码

```java
public interface Incrementable{
 void increment();
}
public class MyIncrement {
  public void increment(){
   System.out.println("Otherincrement()");
  }
  static void f(MyIncrement f){
   f.increment();
  }
}
```



看下面这个类要继承这两个类

如果不用内部类

```java
public class Callee2 extends MyIncrement implements Incrementable{
public void increment(){
    //代码
   }
}
```



想问一下大家increment()这个方法是属于覆盖MyIncrement这里的方法呢？还是Incrementable这里的方法。我怎么能调到MyIncrement这里的方法？显然这是不好区分的。而我们如果用内部类就很好解决这一问题了。看下面代码

```java
public class Callee2 extends MyIncrement{
 private int i=0;
 private void incr() {
    i++;
    System.out.println(i);
 }
 private class Closure implements Incrementable{
   public void increment(){
    incr();
   }
 }
 Incrementable getCallbackReference(){
   return new Closure();
 }
}
```

我们可以用内部类来实现接口，这样就不会与外围类的方法冲突了。

#### 五、静态内部类和非静态内部类的区别

``1、和非静态内部类相比，区别就在于静态内部类没有了指向外部的引用，如果可以声明就失去了它设计的意义了。``
``2、在任何非静态内部类中，都不能有静态数据，静态方法或者又一个静态内部类（内部类的嵌套可以不止一层）。不过静态内部类中却可以拥有这一切。``

``3、java中规定，只有在静态或顶级类型中才可以声明静态字段，主要是为了使别的类的方法能够访问到这个变量。内部类定义在一个类内部，所以不能声明！``

